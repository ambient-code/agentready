"""Generate formatted PR comments for assessment results."""

from typing import Any

from agentready.models.assessment import Assessment
from agentready.models.finding import Finding


class PRCommentGenerator:
    """Generates formatted PR comments from assessment results."""

    @staticmethod
    def generate_summary_comment(
        assessment: Assessment,
        previous_score: float | None = None,
        report_url: str | None = None,
        show_details: bool = True,
    ) -> str:
        """
        Generate a summary comment for a PR.

        Args:
            assessment: Assessment results
            previous_score: Previous assessment score for delta calculation
            report_url: URL to full HTML report
            show_details: Whether to include detailed findings

        Returns:
            Formatted markdown comment
        """
        score = assessment.score
        level = assessment.certification_level.replace("_", " ").title()

        # Header
        lines = ["## AgentReady Assessment Results", ""]

        # Score and level
        if previous_score is not None:
            delta = score - previous_score
            delta_sign = "+" if delta >= 0 else ""
            delta_emoji = "ğŸ“ˆ" if delta > 0 else "ğŸ“‰" if delta < 0 else "â¡ï¸"
            lines.append(
                f"**Score**: {score:.1f}/100 ({level}) {delta_emoji} `{delta_sign}{delta:.1f}`"
            )
            lines.append(f"_Previous: {previous_score:.1f}/100_")
        else:
            lines.append(f"**Score**: {score:.1f}/100 ({level})")

        lines.append("")

        # Summary stats
        passed = len([f for f in assessment.findings if f.status == "pass"])
        failed = len([f for f in assessment.findings if f.status == "fail"])
        skipped = len([f for f in assessment.findings if f.status == "skipped"])

        lines.append(f"- âœ… **Passed**: {passed} attributes")
        lines.append(f"- âŒ **Failed**: {failed} attributes")
        if skipped > 0:
            lines.append(f"- â­ï¸ **Skipped**: {skipped} attributes")

        lines.append("")

        # Link to full report
        if report_url:
            lines.append(f"[ğŸ“Š View Full Report]({report_url})")
            lines.append("")

        # Detailed findings (collapsible)
        if show_details and (failed > 0 or previous_score is not None):
            lines.append("<details>")
            lines.append("<summary>ğŸ“‹ Detailed Findings</summary>")
            lines.append("")

            # Failed attributes
            if failed > 0:
                lines.append("### âŒ Failed Attributes")
                lines.append("")
                for finding in assessment.findings:
                    if finding.status == "fail":
                        lines.append(f"- **{finding.attribute.name}**")
                        if finding.explanation:
                            lines.append(f"  - {finding.explanation}")
                        if finding.remediation and finding.remediation.steps:
                            lines.append(
                                f"  - _Fix: {finding.remediation.steps[0]}_"
                            )
                lines.append("")

            # New failures (if we have previous score)
            if previous_score is not None:
                lines.append("### ğŸ” Changes from Previous Assessment")
                lines.append("")
                lines.append(
                    "_Note: Detailed change tracking requires storing previous findings._"
                )
                lines.append("")

            lines.append("</details>")
            lines.append("")

        # Footer
        lines.append("---")
        lines.append(
            "_Generated by [AgentReady](https://github.com/redhat/agentready)_"
        )

        return "\n".join(lines)

    @staticmethod
    def generate_compact_comment(
        assessment: Assessment, report_url: str | None = None
    ) -> str:
        """
        Generate a compact one-line comment.

        Args:
            assessment: Assessment results
            report_url: URL to full HTML report

        Returns:
            Compact comment text
        """
        score = assessment.score
        level = assessment.certification_level.replace("_", " ").title()

        passed = len([f for f in assessment.findings if f.status == "pass"])
        failed = len([f for f in assessment.findings if f.status == "fail"])

        comment = f"**AgentReady**: {score:.1f}/100 ({level}) | âœ… {passed} passed, âŒ {failed} failed"

        if report_url:
            comment += f" | [ğŸ“Š Full Report]({report_url})"

        return comment

    @staticmethod
    def generate_status_description(assessment: Assessment) -> str:
        """
        Generate a short description for GitHub status checks.

        Args:
            assessment: Assessment results

        Returns:
            Short status description (max ~140 chars for GitHub)
        """
        score = assessment.score
        level = assessment.certification_level.replace("_", " ").title()

        passed = len([f for f in assessment.findings if f.status == "pass"])
        total = len([f for f in assessment.findings if f.status in ["pass", "fail"]])

        return f"AgentReady: {score:.1f}/100 ({level}) - {passed}/{total} passed"

    @staticmethod
    def generate_check_output(
        assessment: Assessment, include_remediation: bool = True
    ) -> tuple[str, str, str]:
        """
        Generate output for GitHub Checks API.

        Args:
            assessment: Assessment results
            include_remediation: Whether to include remediation steps

        Returns:
            Tuple of (title, summary, text) for check output
        """
        score = assessment.score
        level = assessment.certification_level.replace("_", " ").title()

        # Title
        title = f"Score: {score:.1f}/100 ({level})"

        # Summary
        passed = len([f for f in assessment.findings if f.status == "pass"])
        failed = len([f for f in assessment.findings if f.status == "fail"])
        summary = f"Passed {passed} attributes, failed {failed} attributes."

        # Detailed text
        text_lines = ["## Assessment Results", ""]

        if failed > 0:
            text_lines.append("### Failed Attributes")
            text_lines.append("")
            for finding in assessment.findings:
                if finding.status == "fail":
                    text_lines.append(f"**{finding.attribute.name}**")
                    if finding.explanation:
                        text_lines.append(f"- {finding.explanation}")

                    if include_remediation and finding.remediation:
                        if finding.remediation.steps:
                            text_lines.append("- **Remediation:**")
                            for step in finding.remediation.steps[:3]:  # Limit to 3
                                text_lines.append(f"  - {step}")
                    text_lines.append("")

        if passed > 0:
            text_lines.append(f"### âœ… Passed Attributes ({passed})")
            text_lines.append("")
            passed_names = [
                f.attribute.name for f in assessment.findings if f.status == "pass"
            ]
            for name in passed_names[:10]:  # Limit to 10
                text_lines.append(f"- {name}")
            if len(passed_names) > 10:
                text_lines.append(f"- _...and {len(passed_names) - 10} more_")
            text_lines.append("")

        text = "\n".join(text_lines)

        return title, summary, text

    @staticmethod
    def format_trend_ascii(scores: list[float], width: int = 40) -> str:
        """
        Generate ASCII art trend chart from scores.

        Args:
            scores: List of historical scores
            width: Character width of chart

        Returns:
            ASCII chart as multi-line string
        """
        if not scores or len(scores) < 2:
            return "_No trend data available_"

        # Normalize scores to chart height (5 lines)
        height = 5
        min_score = min(min(scores), 0)
        max_score = max(max(scores), 100)
        score_range = max_score - min_score

        if score_range == 0:
            return "_Scores unchanged_"

        # Generate sparkline-style chart
        lines = []
        lines.append(f"Trend (last {len(scores)} assessments):")
        lines.append("")

        # Create chart
        chart_line = ""
        for score in scores:
            normalized = (score - min_score) / score_range
            if normalized >= 0.8:
                chart_line += "â–ˆ"
            elif normalized >= 0.6:
                chart_line += "â–†"
            elif normalized >= 0.4:
                chart_line += "â–„"
            elif normalized >= 0.2:
                chart_line += "â–‚"
            else:
                chart_line += "_"

        lines.append(f"`{chart_line}`")
        lines.append(f"_Range: {min_score:.1f} - {max_score:.1f}_")

        return "\n".join(lines)
